\chapter{Exceptions and Files}

\section{Exceptions}

Consider this program:

\begin{code}
import java.util.Scanner;

public class ErrorProne {

    public static void main(String[] args) {
        int[] data = {10, 66, 47, 11};
        
        Scanner input = new Scanner(System.in);
        
        System.out.print("Enter index 0-3: ");
        int index = input.nextInt();
        
        System.out.print("Enter number to divide by: ");
        int divisor = input.nextInt();
        
        int result = data[index] / divisor;
        System.out.printf("quotient of %d and %d is %d\n",
            data[index], divisor, result);
    }
}
\end{code}

If you enter a non-number the program crashes:

\begin{stdout}
Enter index 0-3: two
Exception in thread "main" java.util.InputMismatchException
	at java.base/java.util.Scanner.throwFor(Scanner.java:939)
	at java.base/java.util.Scanner.next(Scanner.java:1594)
	at java.base/java.util.Scanner.nextInt(Scanner.java:2258)
	at java.base/java.util.Scanner.nextInt(Scanner.java:2212)
	at ErrorProne.main(ErrorProne.java:11)
\end{stdout}
\index{stack trace}
The lines beginning with \texttt{at} are a {\em stack trace}. They show the chain of method calls in reverse chronological order with the file name and line number. You'll want to look for the one that is in your program. In this case, the error was in \texttt{ErrorProne.java:11}, where the \texttt{11} is the line number in the source file with the \java{nextInt} call.

If you enter an index outside the array bounds, the program crashes (the output has been reformatted to fit on the line length of this page):

\begin{stdout}
Enter index 0-3: 5
Enter number to divide by: 0
Exception in thread "main"
  java.lang.ArrayIndexOutOfBoundsException:
  Index 5 out of bounds for length 4
	at ErrorProne.main(ErrorProne.java:21)

\end{stdout}

And if you enter a zero as the divisor, you get yet another error:

\begin{stdout}
Enter index 0-3: 2
Enter number to divide by: 0
Exception in thread "main"
  java.lang.ArithmeticException: / by zero
    at ErrorProne.main(ErrorProne.java:21)
\end{stdout}

All of these errors are called {\em exceptions}---exceptional conditions after which the program cannot continue to run. In Java, we say that the program {\em throws} an exception when it fails.

You already know how to handle these problems: you can use an \java{if} statement with \java{Scanner}'s \java{hasNextInt} method to make sure that the user enters an integer. You can use \java{if} statements to check that the index number is between 0 and the array's length, and that the divisor is non-zero.
\index{\java{try}}
\index{\java{catch}}
In addition to using an \java{if} statement to avoid errors, Java has another general mechanism for catching exceptions before they stop your program:  \java{try} and \java{catch}.

Let's enclose the code that could have an error in a \java{try} block:

\begin{code}
try {
    System.out.print("Enter index 0-3: ");
    int index = input.nextInt();
    
    System.out.print("Enter number to divide by: ");
    int divisor = input.nextInt();
    
    int result = data[index] / divisor;
    System.out.printf("quotient of %d and %d is %d\n",
        data[index], divisor, result);
}
\end{code}

The \java{try} block is followed by a \java{catch} block that specifies the exception we want to handle
and how to handle it.  Let's start with the division by zero, which generated a \java{java.lang.ArithmeticException}:

\begin{code}
catch (ArithmeticException ex) {
    System.out.println("Number to divide by cannot be zero.");
}
\end{code}

If you recompile and run the program and enter \texttt{2} and \texttt{0} as your numbers, you'll get the error message in the \java{catch} block. Notice that the \java{printf} statement after the division doesn't occur---when an exception is thrown, execution imediately jumps to the \java{catch}.

If you enter \texttt{five} or \texttt{5} for the first input, you'll still get the \java{NumberFormatException} or \java{ArrayIndexOutOfBoundsException}.
 
You may follow a \java{try} block with as many \java{catch} blocks as you want. Let's add two more \java{catch} blocks to handle these other two errors:

\begin{code}
catch (NumberFormatException ex) {
    System.out.println("You must enter digits for numbers.");
}
catch (ArrayIndexOutOfBoundsException ex) {
    System.out.printf("Index must be in range 0-%d\n", data.length);
}
\end{code}

The variable in parentheses after \java{catch} is local to the \java{catch} block. This means you can use the same variable name in all the \java{catch} blocks, and, by convention, most programmers name it \java{ex}. (We will put it to use later in the chapter.)

When an exception occurs, Java goes through the \java{catch} blocks in the order that they appear in your program and finds the first one that applies. In the preceding example, we could have put the \java{catch} blocks in any order. However, the order does become important once we examine the hierarchy of exceptions.

\subsection{The Hierarchy of Exceptions}
\index{exceptions!hierarchy}
All exceptions descend from the \java{Exception} class\footnotemark. This list shows many of the most common exceptions you will encounter when learning Java; each category contains many other classes:

\footnotetext{\java{Exception} is a child of the \java{Throwable} class. Another child of \java{Throwable} is \java{Error}, which is used for serious, system-level problems. You will very rarely encounter one of these.}

\begin{itemize}
    \item \java{Exception}
        \begin {itemize}
            \item \java{IOException}
                \begin{itemize}
                    \item \java{FileNotFoundException}
                \end{itemize}
            \item \java{RunTimeException}
            \begin {itemize}
                \item \java{ArithmeticException}
                \item \java{IllegalArgumentException}
                    \begin{itemize}
                        \item \java{IllegalFormatException}
                        \item \java{InvalidParameterException}
                        \item \java{NumberFormatException}
                    \end{itemize}
                \item \java{IndexOutOfBoundsException}
                    \begin{itemize}
                        \item \java{ArrayIndexOutOfBoundsException}
                        \item \java{StringIndexOutOfBoundsException}
                    \end{itemize}
                \item \java{NullPointerException}
              \end{itemize}
    \end{itemize}
\end{itemize}

If you put a \java{catch} for a parent class {\em before} a \java{catch} for a child class, the parent class will catch the error.
Thus, in this code fragment:

\begin{code}
try {
    int n = 12 / 0;
}
catch (Exception ex) {
    System.out.println("Something unexpected occurred.");
}
catch (ArithmeticException ex) {
    System.out.println("You can't divide by zero.");
}
\end{code}

You will see the ``Something unexpected occurred.'' message.  For this reason, always \java{catch} the more specific (child) exception classes before you \java{catch} the more general (parent) exception classes.

\subsection{Using the Exception Variable}
\index{exception variable}
Let's say you \java{catch} the most generic \java{Exception} possible, or one that could have many possible causes, such as \java{FileNotFoundException}. How can you give the user more information than just ``something unexpected occurred''? You can use the variable that you declared in the \java{catch} clause. Here are some methods that you can use\footnotemark:

\footnotetext{These methods are from the \java{Throwable} class, which is the parent of all Java exceptions.}

\begin{description}
  \item[\texttt{getMessage()}] \hfill \\ Returns a detailed message string
  \item[\texttt{toString()}] \hfill \\ Returns a short description
  \item[\texttt{printStackTrace()}] \hfill \\ This \java{void} method prints the exception and its stack trace to the standard error stream, which is your terminal window
\end{description}

For example, you could \java{catch} {\em only} \java{Exception} and use one of these methods to tell users what went wrong:

\begin{code}
catch (Exception ex) {
    System.out.println("An error occurred:");
    System.out.println(ex.toString());
}
\end{code}

You can see this in action in file {\it ErrorProneGeneralException.java} in the code repository. As you can see, the error messages are not as satisfactory as those you would write yourself when handling the specific exceptions.

\subsection{The \java{finally} clause}
\index{\java{finally}}
Sometimes programs need to take an action whether the code in the \java{try} block succeeded or not. (For example, if you have allocated resources and want to ``clean up'' before exiting the program.) This is the role of the \java{finally} clause. It is executed whether the \java{try} block succeeded or an exception was caught by a \java{catch} block. In fact, it is executed even when there is a \java{return} or \java{break} in a block:

\begin{code}
public class FinallyTest {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        try {
            int result = 17 / 5;
            System.out.printf("quotient of 17 and 5 is %d\n",
               result);
            return; // exits the main() method
        }
        catch (ArithmeticException ex) {
            System.out.println("You can't divide by zero.");
        }
        finally {
            System.out.println("In the finally clause.");
        }
        System.out.println("Does not print if return succeeds");
    }
}
\end{code}

This program will print \texttt{In the finally clause.} even though the \java{return} prevents the last \java{println} from happening.

\subsection{Checked and Unchecked Exceptions}
\index{unchecked exceptions}
\index{exceptions!unchecked}

All of the exceptions used in the preceding examples (and all exceptions that are descendants of \java{RuntimeException}) are called {\em unchecked exceptions}. Java doesn't require you to enclose operations that cause such exceptions in a \java{try}-\java{catch} block. This is a good thing, or you'd need \java{try}-\java{catch} blocks around every division, array access, and string-to-numeric conversion.

For many operations that could throw an unchecked exception, you are better off using an \java{if} statement to avoid the error in the first place. You can, for example, use an \java{if} to check if an index is within array bounds, a divisor is non-zero, or if the user has actually entered data that can be converted to integer. This also gives you greater control over the program flow and structure. See, for example, the {\it NormalErrorChecking.java} file in the code repository.

\index{checked exceptions}
\index{exceptions!checked}

So, why are we talking about \java{try} and \java{catch} at all? Because there are some exceptions that can't easily be handled by an \java{if}-\java{else}. These exceptions are called {\em checked exceptions}. The Java compiler requires you to enclose operations that might throw these exceptions in a \java{try} block and provide a \java{catch} block to handle them. Foremost of these exceptions is the \java{IOException}, generated by I/O (Input/Output) operations. When you are working with files in Java, you will need to check this exception. This leads us to the next major topic in this chapter:

\section{Files}

Up to this point, you've entered all the data for a program from the keyboard, using a \java{Scanner} with \java{System.in}.  What if someone sends you a file of several months' worth of weather data from Munich, Germany, in a file named {\em klima.txt}. You can find this file in the {\em code/ch018} folder in the repository\footnotemark.

\footnotetext{The file is an edited version of the data at \url{https://opendata.dwd.de/climate_environment/CDC/observations_germany/climate/daily/kl/recent/tageswerte_KL_03379_akt.zip}}

\begin{stdout}
MESS_DATUM;TMK;TXK;TNK
20200106;0.8;6.0;-2.5
20200107;2.4;4.6;-2.1
20200108;3.6;7.2;-1.3
20200109;7.7;14.5;3.6
...
20210704;17.9;22.9;14.7
20210705;18.5;22.4;13.9
20210706;21.8;31.5;15.4
20210707;18.2;20.5;16.7
20210708;16.9;20.1;14.7
\end{stdout}

The columns stand for date, average daily temperature, high temperature, and low temperature (temperatures are in $^\circ$C).
If you want to find the maximum temperature and minimum temperature across the whole time period, you certainly don't want to have to type all the numbers again at the keyboard. Instead, you want Java to be able to read the file from your disk.

\subsection{The \java{File} Object}
In order to access a file, you must use its path name to create a \java{File} object. A path name describes how to get to a file in the file system. For this chapter, we’ll presume that your data files are in the same directory as the {\em .class} file for your program. That way, the path name is the same as the file name. (For more details about path names, see Appendix~\ref{pathnames}.)

The resulting object doesn't give you access to the file contents; rather, it gives you access to information about the file.

Here's the start of a program that lets you enter a path name and find out about that file:

\begin{code}
import java.util.Scanner;
import java.io.File; // this is a new import

public class FileInfo {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Enter a path name: ");
        String pathName = input.nextInt();
        
        File f = new File(pathName);
\end{code}

The variable \java{f} is what, in other programming languages, is called a {\em file handle} or {\em file descriptor}. The code continues by calling some of the more useful methods in the \java{File} class:

\begin{code}
        System.out.println("File exists: " + f.exists());
        System.out.println("File size:   " + f.length());
        System.out.println("Readble:     " + f.canRead());
        System.out.println("Writeable:   " + f.canWrite());
        System.out.println("Executable:  " + f.canExecute());
        System.out.println("Directory:   " + f.isDirectory());
        System.out.println("Normal file: " + f.isFile());
        System.out.println("Hidden file: " + f.isHidden());
    }
}
\end{code}

A couple of notes: the \java{length} method returns the file size in bytes. It is possible for a file to be neither a directory nor a ``normal file''---the \texttt{/dev/zero} path on Linux refers to a {\em virtual file} that is neither.

The \java{File} class also has methods that let you delete files, rename them, and create directories. For details, see \url{https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html}.

\subsection{Reading Files}

Let's write a program that opens the {\em klima.txt} file and finds the maximum and minimum daily temperature across the time period described in the file.

In order to read the contents of a file, you must open a \java{Scanner} based on the \java{File} object. But if you try code like this:

\begin{code}
import java.util.Scanner;
import java.io.File;

public class LineCount {

    public static void main(String[] args) {        
        File f = new File("klima.txt");
        
        Scanner input = new Scanner(f);
    }
}
\end{code}

The compiler will complain (message reformatted to fit page width):

\begin{stdout}
Klima.java:9: error: unreported exception
FileNotFoundException; must be caught or declared to be thrown
        Scanner input = new Scanner(f);
                        ^
1 error
\end{stdout}

The \java{FileNotFoundException} is a {\em checked exception}, and the compiler insists that you either catch it or throw it to the caller\footnotemark.

\footnotetext{You already know how to \java{catch} an exception. For details on specifying that a method throws an exception, see \url{https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html}}

This will require you to import \java{java.io.FileNotFoundException} and set up a \java{try}-\java{catch} block. 

\begin{code}
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Klima {

    public static void main(String[] args) {        
        File f = new File("klima.txt");
        try {
            Scanner input = new Scanner(f);
            // code goes here
            input.close();
        }
        catch (FileNotFoundException ex) {
            System.out.println("Can't find file klima.txt");
        }
    }
}
\end{code}

Now we are set to read the file's contents. Rather than write the whole program right now, let's start by reading the file one line at a time, printing them out to the screen, and counting the number of lines. Here's the code that goes inside the \java{try} block. The \java{hasNextLine} method returns \java{false} when it hits the end of the file:

\begin{code}
            while (input.hasNextLine()) {
                String oneLine = input.nextLine();
                System.out.println(oneLine);
                lineCount++;
            }
            System.out.println("# of lines: " + lineCount);
            input.close();
\end{code}

Now, that we know that we can sucessfully open and read the file, we can modify the code to accomplish the task we want to do: finding the minimum and maximum temperatures.

The program will read lines one at a time and then extract the data from each line. Because \java{Scanner}'s \java{next} and \java{nextDouble} methods use whitespace to separate items, we can't use them ``as-is'' here, where data items are separated by semicolons. We could solve this problem by using the \java{useDelimiter} method to change the separator to a semicolon, but that would deprive us of the opportunity to learn about a new \java{String} method and practice more with exceptions.

Let's replace the line-counting code with this code for finding the maximum and minimum temperatures:

\begin{code}
double max = -1000.0;
double min = 1000.0;
String[] items = oneLine.split(";");
if (items.length == 4) {
    dayMax = Double.parseDouble(items[2]);
    dayMin = Double.parseDouble(items[3]);
    if (dayMax > max) {
        max = dayMax;
    }
    if (dayMin < min) {
        min = dayMin;
    }
}
\end{code}

The new \java{String} method is \java{split}. Given a delimiter, this method splits the given \java{String} into an array of strings wherever it finds the delimiter that you give it as an argument. For example, after this code executes:

\begin{code}
String s = "sister-in-law";
String[] parts = s.split("-");
\end{code}

The \java{parts} array will be \java{\{"sister", "in", "law"\}}.

Similarly, the program uses \java{oneLine.split(";")} to separate the items on each line. If there aren't four items on a line, it's incomplete, and the program does nothing (effectively skipping over the line).

We now have a problem: the first line doesn't have any numbers on it, and trying to use \java{parseDouble} on the titles will throw a \java{NumberFormatException}. To solve this problem (which could also occur if the file we were given had bad data in it), we use another \java{try}-\java{catch}:

\begin{code}
try {
    double dayMax = Double.parseDouble(items[2]);
    double dayMin = Double.parseDouble(items[3]);
}
catch (NumberFormatException ex) {
    System.out.println("Ignoring non-numeric data "
        + ex.getMessage());
}
\end{code}


\subsection{Writing Files}

There are many Java classes for reading files. In this book, we've been using \java{Scanner} to read input because it contains many methods to make getting input simple.

In a similar way, there are many Java classes for writing files. We'll discuss only one of them: \java{PrintWriter}. To use this class, you must:

\begin{code}
import java.io.PrintWriter;
\end{code}

Just as you created a \java{File} object and created a \java{Scanner} with that \java{File} object as a parameter, you can write to a disk file by creating a \java{File} object with the path you want and then use that object as a parameter to the \java{PrintWriter} constructor. And, just as the compiler required you to enclose the code in a \java{try}-\java{catch} block, you must do the same when opening a \java{PrintWriter}

\begin{code}
File f = new File("output.txt");
try {
    PrintWriter output = new PrintWriter(f);
    // code to write to file goes here
}
catch (FileNotFoundException ex) {
    System.out.println("Unable to open output file.");
}
\end{code}

Just like \java{System.out}, the \java{PrintWriter} object \java{output} we have created has \java{print}, \java{println}, and \java{printf} methods. Instead of writing to your screen, they write data to the file you specified.

\subsection {Writing Files - Two Important Notes}

\begin{enumerate}
\item When you open a \java{PrintWriter} to a \java{File} that does not exist, it will be created for you. If you open a \java{PrintWriter} to a \java{File} that {\em does} exist, {\bf the existing file will be deleted and re-created}. Any information that was in the file will be gone, even if you never write anything to the \java{PrintWriter}.

This means that it is always useful to use the \java{exists} method to check if a file already exists and, when possible, give the user the option to overwrite the old file or exit the program.

\item When you do a \java{println} to a \java{PrintWriter}, the data is not written to disk immediately. Instead, it is kept in a {\em buffer}, and is written only when the buffer is full. If you exit the program with the buffer partially filled, there is a chance that it might not be written to disk. {\em Always} call the \java{close} method on your output files to make sure that the buffer is written to disk.

If you run this program:

\begin{code}
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;

public class PartialWrite {

    public static void main(String[] args) {        
        File f = new File("write_test.txt");
        try {
            PrintWriter output = new PrintWriter(f);
            output.println("Example of writing to a file.");
            // output.close(); // uncomment this line 
        }
        catch (FileNotFoundException ex) {
            System.out.println("Can't open file write_test.txt");
        }
    }
}
\end{code}

without closing the file, the resulting {\em write\_test.txt} file will be empty.
If you uncomment the \java{output.close();} line and run the program again, the file will contain the output.
 
\end{enumerate}
